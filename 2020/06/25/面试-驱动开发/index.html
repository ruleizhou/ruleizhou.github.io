<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="google-site-verification" content="Ezui-oQp8Pno7S0Zg3T794uNOShGTYHv9PGKQ5Y1Au0">
















  
  
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css">







<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>

<script src="https://cdn.bootcss.com/echarts/4.1.0-release/echarts.min.js"></script>


  




  <meta name="description" content="1 Linux相关1.1 Linux中用户模式和内核模式是什么含意？1.2 linux用户进程间通信主要有哪几种方式？1.3 linux内存如何划分及如何使用？虚拟地址及物理地址的概念及转换，高端内存的概念？1.4 linux中内核空间和用户空间区别？用户空间和内核空间通信方式有哪些？1.5 linux中系统调用过程？如应用程序中read()在linux中执行过程（从用户空间到内核空间）？1.6">
<meta name="keywords" content="面试">
<meta property="og:type" content="article">
<meta property="og:title" content="面试-驱动开发">
<meta property="og:url" content="https://ruleizhou.github.io/2020/06/25/面试-驱动开发/index.html">
<meta property="og:site_name" content="ZRL">
<meta property="og:description" content="1 Linux相关1.1 Linux中用户模式和内核模式是什么含意？1.2 linux用户进程间通信主要有哪几种方式？1.3 linux内存如何划分及如何使用？虚拟地址及物理地址的概念及转换，高端内存的概念？1.4 linux中内核空间和用户空间区别？用户空间和内核空间通信方式有哪些？1.5 linux中系统调用过程？如应用程序中read()在linux中执行过程（从用户空间到内核空间）？1.6">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://ruleizhou.github.io/2020/06/25/面试-驱动开发/i2c_start.png">
<meta property="og:image" content="https://ruleizhou.github.io/2020/06/25/面试-驱动开发/i2c_send.png">
<meta property="og:image" content="https://ruleizhou.github.io/2020/06/25/面试-驱动开发/I2C_Write.png">
<meta property="og:image" content="https://ruleizhou.github.io/2020/06/25/面试-驱动开发/I2C_read.png">
<meta property="og:image" content="https://ruleizhou.github.io/2020/06/25/面试-驱动开发/I2C_Architecture.png">
<meta property="og:image" content="https://ruleizhou.github.io/2020/06/25/面试-驱动开发/I2C_driver.png">
<meta property="og:image" content="https://ruleizhou.github.io/2020/06/25/面试-驱动开发/I2C_driver_api.png">
<meta property="og:image" content="https://ruleizhou.github.io/2020/06/25/面试-驱动开发/end_oops.webp">
<meta property="og:image" content="https://ruleizhou.github.io/2020/06/25/面试-驱动开发/irq_liucheng.jpg">
<meta property="og:image" content="https://ruleizhou.github.io/2020/06/25/面试-驱动开发/Interrupt_response.png">
<meta property="og:updated_time" content="2020-06-30T02:59:34.012Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试-驱动开发">
<meta name="twitter:description" content="1 Linux相关1.1 Linux中用户模式和内核模式是什么含意？1.2 linux用户进程间通信主要有哪几种方式？1.3 linux内存如何划分及如何使用？虚拟地址及物理地址的概念及转换，高端内存的概念？1.4 linux中内核空间和用户空间区别？用户空间和内核空间通信方式有哪些？1.5 linux中系统调用过程？如应用程序中read()在linux中执行过程（从用户空间到内核空间）？1.6">
<meta name="twitter:image" content="https://ruleizhou.github.io/2020/06/25/面试-驱动开发/i2c_start.png">





  
  
  <link rel="canonical" href="https://ruleizhou.github.io/2020/06/25/面试-驱动开发/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>面试-驱动开发 | ZRL</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZRL</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ruleizhou.github.io/2020/06/25/面试-驱动开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rulei.Zhou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/han.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZRL">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面试-驱动开发

              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-06-25 20:36:10" itemprop="dateCreated datePublished" datetime="2020-06-25T20:36:10+08:00">2020-06-25</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-06-30 10:59:34" itemprop="dateModified" datetime="2020-06-30T10:59:34+08:00">2020-06-30</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Linux相关">1 Linux相关</h1><h2 id="Linux中用户模式和内核模式是什么含意？">1.1 Linux中用户模式和内核模式是什么含意？</h2><h2 id="linux用户进程间通信主要有哪几种方式？">1.2 linux用户进程间通信主要有哪几种方式？</h2><h2 id="linux内存如何划分及如何使用？虚拟地址及物理地址的概念及转换，高端内存的概念？">1.3 linux内存如何划分及如何使用？虚拟地址及物理地址的概念及转换，高端内存的概念？</h2><h2 id="linux中内核空间和用户空间区别？用户空间和内核空间通信方式有哪些？">1.4 linux中内核空间和用户空间区别？用户空间和内核空间通信方式有哪些？</h2><h2 id="linux中系统调用过程？如应用程序中read-在linux中执行过程（从用户空间到内核空间）？">1.5 linux中系统调用过程？如应用程序中read()在linux中执行过程（从用户空间到内核空间）？</h2><h2 id="linux调度原理">1.6 linux调度原理</h2><h2 id="linux-RCU原理">1.7 linux RCU原理</h2><h2 id="linux编译时用到的参数含义">1.8 linux编译时用到的参数含义</h2><h2 id="linux内核的启动过程（源代码级）">1.9 linux内核的启动过程（源代码级）</h2><h1 id="基础相关">2 基础相关</h1><h2 id="怎么用C先嵌入式系统的死循环的？">2.1 怎么用C先嵌入式系统的死循环的？</h2><h2 id="copy-to-user-和copy-from-user-主要用于实现什么功能？一般用于file-operations结构的哪些函数里面？">2.2 copy_to_user() 和copy_from_user()主要用于实现什么功能？一般用于file_operations结构的哪些函数里面？</h2><h2 id="ioctl和unlock-ioctl有什么区别？">2.3 ioctl和unlock_ioctl有什么区别？</h2><h2 id="kmalloc和vmalloc的区别">2.4 kmalloc和vmalloc的区别</h2><h2 id="内核函数mmap的实现原理，机制？">2.5 内核函数mmap的实现原理，机制？</h2><h2 id="怎样申请大块内核内存？">2.6 怎样申请大块内核内存？</h2><h2 id="framebuffer机制">2.7 framebuffer机制</h2><h2 id="内核配置编译及Makefile">2.8 内核配置编译及Makefile</h2><h2 id="列举最少3种你所知道的嵌入式的体系结构，并请说明什么时ARM体系结构？">2.9 列举最少3种你所知道的嵌入式的体系结构，并请说明什么时ARM体系结构？</h2><h1 id="驱动模型相关">3 驱动模型相关</h1><h2 id="字符设备和块设备的区别，请分别列举一些实际的设备说出它们是属于哪一类设备？">3.1 字符设备和块设备的区别，请分别列举一些实际的设备说出它们是属于哪一类设备？</h2><h2 id="请简述主设备号和次设备号的用途。如果执行mknod-chartest-c-4-64，创建chartest设备。请分析chartest使用的是哪一类设备驱动程序？">3.2 请简述主设备号和次设备号的用途。如果执行mknod chartest c 4 64，创建chartest设备。请分析chartest使用的是哪一类设备驱动程序？</h2><h2 id="设备驱动程序中如何注册一个字符设备？分别解释下它的几个参数的含义？">3.3 设备驱动程序中如何注册一个字符设备？分别解释下它的几个参数的含义？</h2><h2 id="字符型驱动设备怎么创建文件？">3.4 字符型驱动设备怎么创建文件？</h2><h2 id="insmod一个驱动模块，会执行模块中的哪个函数？rmmod呢？这两个函数在设计上要注意哪些？遇到过卸载驱动出现异常没？是什么问题引起的？">3.5 insmod一个驱动模块，会执行模块中的哪个函数？rmmod呢？这两个函数在设计上要注意哪些？遇到过卸载驱动出现异常没？是什么问题引起的？</h2><h2 id="设备驱动模型三个重要的成员是？platform总线的匹配规则是？在具体应用上要不要先注册驱动在注册设备？有先后顺序没？">3.6 设备驱动模型三个重要的成员是？platform总线的匹配规则是？在具体应用上要不要先注册驱动在注册设备？有先后顺序没？</h2><h2 id="驱动中操作物理绝对地址为什么要先ioremap？">3.7 驱动中操作物理绝对地址为什么要先ioremap？</h2><h2 id="查看驱动模块中打印信息应该使用什么命令？如何查看内核中已有的字符设备的信息？如何查看正在使用的哪些中断号？">3.8 查看驱动模块中打印信息应该使用什么命令？如何查看内核中已有的字符设备的信息？如何查看正在使用的哪些中断号？</h2><h1 id="Bus相关">4 Bus相关</h1><h2 id="I2C">4.1 I2C</h2><h3 id="I2C总线协议和时序">4.1.1 I2C总线协议和时序</h3><p>IIC标准速率为100Kbit/s,快速模式400Kbit/s，支持多机通信，支持多主控模块，但是同一时刻只允许有一个主控。由数据线SDA和时钟SCL构成串行总线；每个电路模块都有唯一地址。</p>
<h4 id="总线空闲状态">4.1.1.1 总线空闲状态</h4><p>I2C总线的SDA和SCL两条信号线同时处于高电平时，规定为总线的空闲状态。此时各个器件的输出级的场效应管均处于截止状态，即释放总线，由两条信号线各自的上拉电阻把电平拉高。</p>
<h4 id="启动信号（start）">4.1.1.2 启动信号（start）</h4><p>在时钟线SCL保持高电平期间，数据线SDA上的电平被拉低（负跳变），定义为I2C总线的启动信号，它标志着一次数据传输的开始。启动信号是由主控器主动建立的，在建立该信号之前 I2C 总线必须处于空闲状态。</p>
<p><img src="/2020/06/25/面试-驱动开发/i2c_start.png" alt></p>
<h4 id="停止信号（stop）">4.1.1.3 停止信号（stop）</h4><p>在时钟线SCL保持高电平期间，数据线SDA被释放，使得SDA返回高电平（即正跳变），称为I2C总线的停止信号，它标志着一次数据传输的终止。停止信号也是由主控器主动建立的，建立该信号之后，I2C总线将返回空闲状态。</p>
<h4 id="数据位传送">4.1.1.4 数据位传送</h4><p>在I2C总线上传送的每一位数据都有一个时钟脉冲相对应（或同步控制），即在SCL串行时钟的配合下，在SDA上逐位地串行传送每一位数据。进行数据传送时，在SCL呈现高电平期间，SDA上的电平必须保持稳定，低电平为数据0，高电平为数据1。只有在SCL为低电平期间，才允许SDA上的电平改变状态。</p>
<p><img src="/2020/06/25/面试-驱动开发/i2c_send.png" alt></p>
<h4 id="应答信号（ACK）">4.1.1.5 应答信号（ACK）</h4><p>I2C总线上的所有数据都是以8位传送的，发送器每发送一个字节，就在时钟脉冲9期间释放数据线，由接收器反馈一个应答信号。应答信号为低电平时，规定为有效应答位（ACK简称应答位），表示接收器已经成功地接收了该字节；应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功。对于反馈有效应答位ACK的要求是，接收器在第9个时钟脉冲之前的低电平期间将 SDA 线拉低，并且确保在该时钟的高电平期间为稳定的低电平。</p>
<p>如果接收器是主控器，则在它收到最后一个字节后，发送一个NACK信号，以通知被控发送器结束数据发送，并释放SDA线，以便主控接收器发送一个停止信号。</p>
<h3 id="I2C通讯时序图">4.1.2 I2C通讯时序图</h3><ul>
<li><p>写时序</p>
<p><img src="/2020/06/25/面试-驱动开发/I2C_Write.png" alt></p>
</li>
<li><p>读时序</p>
<p><img src="/2020/06/25/面试-驱动开发/I2C_read.png" alt></p>
</li>
</ul>
<h3 id="I2C总线体系结构">4.1.3 I2C总线体系结构</h3><p><img src="/2020/06/25/面试-驱动开发/I2C_Architecture.png" alt></p>
<p>主要包括：<strong>IIC核心、IIC总线驱动、IIC设备驱动</strong>。</p>
<ol>
<li>I2C总线驱动：对应一个SOC的IIC控制器</li>
<li>I2C设备驱动：对应一个具体的IIC外设</li>
<li>I2C核心：具体的外设挂载在具体的IIC控制器上，因此IIC设备驱动需要和I2C总线驱动对应。因此需要I2C核心match。</li>
</ol>
<h4 id="相关结构体">4.1.3.1 相关结构体</h4><ul>
<li><p>struct i2c_adapter（I2C适配器）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>             <span class="comment">// 所有者</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="class"><span class="keyword">class</span>;</span>               <span class="comment">// 该适配器支持的从设备的类型</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span> <span class="comment">// 该适配器与从设备的通信算法</span></span><br><span class="line">    <span class="keyword">void</span> *algo_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* data fields that are valid for all devices    */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> timeout;              <span class="comment">// 超时时间</span></span><br><span class="line">    <span class="keyword">int</span> retries;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>        <span class="comment">// 该适配器设备对应的device</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nr;                   <span class="comment">// 适配器的编号</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">48</span>];            <span class="comment">// 适配器的名字</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">userspace_clients</span>;</span>  <span class="comment">// 用来挂接与适配器匹配成功的从设备i2c_client的一个链表头</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct i2c_adapter是用来描述一个I2C适配器，在SoC中的指的就是内部外设I2C控制器，当向I2C核心层注册一个I2C适配器时就需要提供这样的一个结构体变量。</p>
</li>
<li><p>struct i2c_algorithm（I2C算法）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line">    <span class="comment">/* If an adapter algorithm can't do I2C-level access, set master_xfer</span></span><br><span class="line"><span class="comment">       to NULL. If an adapter algorithm can do SMBus access, set</span></span><br><span class="line"><span class="comment">       smbus_xfer. If set to NULL, the SMBus protocol is simulated</span></span><br><span class="line"><span class="comment">       using common I2C messages */</span></span><br><span class="line">    <span class="comment">/* master_xfer should return the number of messages successfully</span></span><br><span class="line"><span class="comment">       processed, or a negative value on error */</span></span><br><span class="line">    <span class="keyword">int</span> (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,</span><br><span class="line">               <span class="keyword">int</span> num);</span><br><span class="line">    <span class="keyword">int</span> (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,</span><br><span class="line">               <span class="keyword">unsigned</span> short flags, <span class="keyword">char</span> read_write,</span><br><span class="line">               u8 command, <span class="keyword">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line">    u32 (*functionality) (struct i2c_adapter *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct i2c_algorithm结构体代表的是适配器的通信算法，在构建i2c_adapter结构体变量的时候会去填充这个元素。</p>
</li>
<li><p>struct i2c_client</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> &#123;</span>    <span class="comment">//  用来描述一个i2c次设备</span></span><br><span class="line">    <span class="keyword">unsigned</span> short flags;        <span class="comment">//  描述i2c次设备特性的标志位</span></span><br><span class="line">    <span class="keyword">unsigned</span> short addr;         <span class="comment">//  i2c 次设备的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> name[I2C_NAME_SIZE];    <span class="comment">//  i2c次设备的名字</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span> <span class="comment">//  指向与次设备匹配成功的适配器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> *<span class="title">driver</span>;</span>   <span class="comment">//  指向与次设备匹配成功的设备驱动</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>           <span class="comment">//  该次设备对应的device</span></span><br><span class="line">    <span class="keyword">int</span> irq;                     <span class="comment">//  次设备的中断引脚</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">detected</span>;</span>   <span class="comment">//  作为一个链表节点挂接到与他匹配成功的i2c_driver 相应的链表头上</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>struct device_driver</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> &#123;</span>    <span class="comment">// 代表一个i2c设备驱动</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="class"><span class="keyword">class</span>;</span>      <span class="comment">// i2c设备驱动所支持的i2c设备的类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notifies the driver that a new bus has appeared or is about to be</span></span><br><span class="line"><span class="comment">     * removed. You should avoid using this if you can, it will probably</span></span><br><span class="line"><span class="comment">     * be removed in a near future.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*attach_adapter)(struct i2c_adapter *);   <span class="comment">// 用来匹配适配器的函数 adapter</span></span><br><span class="line">    <span class="keyword">int</span> (*detach_adapter)(struct i2c_adapter *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Standard driver model interfaces */</span></span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct i2c_client *, <span class="keyword">const</span> struct i2c_device_id *); <span class="comment">// 设备驱动层的probe函数</span></span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct i2c_client *);                              <span class="comment">// 设备驱动层卸载函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* driver model interfaces that don't relate to enumeration  */</span></span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct i2c_client *);</span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct i2c_client *, <span class="keyword">pm_message_t</span> mesg);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct i2c_client *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Alert callback, for example for the SMBus alert protocol.</span></span><br><span class="line"><span class="comment">     * The format and meaning of the data value depends on the protocol.</span></span><br><span class="line"><span class="comment">     * For the SMBus alert protocol, there is a single bit of data passed</span></span><br><span class="line"><span class="comment">     * as the alert response's low bit ("event flag").</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*alert)(struct i2c_client *, <span class="keyword">unsigned</span> <span class="keyword">int</span> data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* a ioctl like command that can be used to perform specific functions</span></span><br><span class="line"><span class="comment">     * with the device.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*command)(struct i2c_client *client, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span>           <span class="comment">//  该i2c设备驱动所对应的device_driver</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> *<span class="title">id_table</span>;</span>  <span class="comment">//  设备驱动层用来匹配设备的id_table</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Device detection callback for automatic device creation */</span></span><br><span class="line">    <span class="keyword">int</span> (*detect)(struct i2c_client *, struct i2c_board_info *);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> short *address_list;    <span class="comment">//  该设备驱动支持的所有次设备的地址数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clients</span>;</span>              <span class="comment">//  用来挂接与该i2c_driver匹配成功的i2c_client (次设备)的一个链表头</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>struct i2c_board_info</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  这个结构体是用来描述板子上的一个i2c设备的信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>        type[I2C_NAME_SIZE];  <span class="comment">//设备名，最长20个字符，最终安装到client的name上</span></span><br><span class="line">    <span class="keyword">unsigned</span> short    flags;  <span class="comment">//最终安装到client.flags</span></span><br><span class="line">    <span class="keyword">unsigned</span> short    addr;  <span class="comment">//设备从地址slave address，最终安装到client.addr上</span></span><br><span class="line">    <span class="keyword">void</span>        *platform_data;  <span class="comment">//设备数据，最终存储到i2c_client.dev.platform_data上</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span>    *<span class="title">archdata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span>  <span class="comment">//OpenFirmware设备节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">acpi_dev_node</span> <span class="title">acpi_node</span>;</span></span><br><span class="line">    <span class="keyword">int</span>        irq;  <span class="comment">//设备采用的中断号，最终存储到i2c_client.irq上</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_devinfo</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">list</span>;</span>            <span class="comment">// 作为一个链表节点挂接到__i2c_board_list 链表上去</span></span><br><span class="line">    <span class="keyword">int</span>            busnum;               <span class="comment">// 适配器的编号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span>    <span class="title">board_info</span>;</span> <span class="comment">//  内置的i2c_board_info 结构体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="I2C设备驱动">4.1.3.2 I2C设备驱动</h4><p>负责实现i2c_driver（包含一套驱动方法，操作具体的I2C外部设备方法）和i2c_client（包含具体的I2C外部设备的硬件信息，还有一些内核自动填充的信息）两个数据结构。一个i2c_driver可以驱动多个同类i2c_client。</p>
<p>设备驱动的实现方法有两种：</p>
<ul>
<li>i2c-dev：这种方法只封装了操作SOC中I2C控制器的一些方法。需要在用户层直接控制硬件IIC，属于“应用层驱动”</li>
<li>在驱动层封装所有的设备驱动方法，向用户层提供最终的操作结果，硬件的操作在驱动层完成。（常用）</li>
</ul>
<p><img src="/2020/06/25/面试-驱动开发/I2C_driver.png" alt></p>
<p>图注：I2C控制器本身挂载在Platform总线上。由i2c_board_info描述。</p>
<h4 id="I2C核心">4.1.3.3 I2C核心</h4><p>I2C总线驱动和IIC设备驱动的注册和注销，I2C上层通信代码实现，探测设备，检测设备地址和上层代码实现。实现设备和I2C控制器的分离。</p>
<h4 id="I2C总线驱动">4.1.3.4 I2C总线驱动</h4><p>实现IIC适配器数据结构【i2c_adapter对应一个SOC里面硬件的IIC控制器】，i2c适配器的algorithm数据结构【i2c_algorithm实现IIC通信方法】。</p>
<h3 id="I2C设备驱动编写">4.1.4 I2C设备驱动编写</h3><p>IIC驱动编写和一般字符设备编写API区别和工作流程：</p>
<p><img src="/2020/06/25/面试-驱动开发/I2C_driver_api.png" alt></p>
<h1 id="Debug相关">5 Debug相关</h1><h2 id="Kernel-Oops和Panic是一回事吗">5.1 Kernel Oops和Panic是一回事吗</h2><p>ops英文单词的中文含义是“哎呀”，表示“惊叹”；Panic英文单词的中文含义是“惊慌”。所以panic的程度显然是高于oops的，因为惊叹不一定会惊慌，而惊慌最容易失措，内核panic后，就死机了，俗称内核崩溃。但是内核报oops，这个时候不见得会panic，它可能只是报个oops，杀死进程而已。</p>
<p><img src="/2020/06/25/面试-驱动开发/end_oops.webp" alt></p>
<p>从代码逻辑可以看出，当这个oops发生的时候，如何in_interrupt()成立，或者panic_on_oops成立，都是直接panic()，否则只是以一个信号退出进程而已。</p>
<p>由此可见，如果我们在一个中断上下文，这个oops必须抛panic；否则如果只是一个进程上下文，打印个oops，进程退出即可。另外，如果/proc/sys/kernel/panic_on_oops设置的值是1，这个时候，不管你在什么上下文，都是要panic的。</p>
<ul>
<li><p>在硬中断；</p>
</li>
<li><p>在软中断(soft irq)；</p>
</li>
<li><p>在NMI</p>
<p>NMI (Non Maskable Interrupt)——不可屏蔽中断(即CPU不能屏蔽)</p>
<p>不可屏蔽中断请求信号NMI用来通知CPU，发生了“灾难性”的事件，如电源掉电、存储器读写出错、总线奇偶位出错等。NMI线上中断请求是不可屏蔽的（即无法禁止的）、而且立即被CPU锁存。因此NMI是边沿触发，不需要电平触发。NMI的优先级也比INTR高。不可屏蔽中断的类型指定为2，在CPU响应NMI时，不必由中断源提供中断类型码，因此NMI响应也不需要执行总线周期INTA</p>
</li>
</ul>
<h2 id="Kernel-Panic">5.2 Kernel Panic</h2><p><a href="https://ruleizhou.github.io/2020/06/28/kernel-panic-%E8%AF%A6%E8%A7%A3/">了解kernel panic 流程</a></p>
<h1 id="同步相关">6 同步相关</h1><h2 id="linux中的同步机制？">6.1 linux中的同步机制？</h2><h3 id="自旋锁">6.1.1 自旋锁</h3><p>得不到资源时，会原地打转，知道获取资源为止。</p>
<p>使用步骤如下：</p>
<ol>
<li><p>定义自旋锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">spinlock_t</span> spin;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化自旋锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_init(lock);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取自旋锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得自旋锁，如果能立即获得，则马上返回，否则自旋在那里，直到该自旋锁的保持者释放</span></span><br><span class="line">spin_lock(lock);</span><br><span class="line"><span class="comment">//尝试获得自旋锁，如果能立即获得，它获得并返回真，否则立即返回假，实际上，不再“在原地打转”</span></span><br><span class="line">spin_trylock(lock);</span><br></pre></td></tr></table></figure>
</li>
<li><p>释放自旋锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spin_unlock(lock)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>使用示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">spinlock_t</span> lock;</span><br><span class="line">spin_lock_init(&amp;lock);     </span><br><span class="line">spin_lock(&amp;lock);<span class="comment">//获取自旋锁，保护临界区</span></span><br><span class="line">...<span class="comment">//临界区</span></span><br><span class="line">spin_unlock(&amp;lock);<span class="comment">//解锁</span></span><br></pre></td></tr></table></figure>

<h3 id="互斥锁">6.1.2 互斥锁</h3><ol>
<li><p>定义并初始化互斥锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">my_mutex</span>;</span></span><br><span class="line">mutex_init(&amp;my_mutex);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取互斥锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_lock</span><span class="params">(struct mutex *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">mutex_lock_interruptible</span><span class="params">(strutct mutex *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">mutex_trylock</span><span class="params">(struct mutex *lock)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>释放互斥锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_unlock</span><span class="params">(struct mutex *lock)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>使用示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">my_mutex</span>;</span></span><br><span class="line">mutex_init(&amp;my_mutex);</span><br><span class="line"> </span><br><span class="line">mutex_lock(&amp;my_mutex);</span><br><span class="line">...<span class="comment">//临界资源</span></span><br><span class="line">mutex_unlock(&amp;my_mutex);</span><br></pre></td></tr></table></figure>

<h3 id="信号量">6.1.3 信号量</h3><p>得不到资源，会进入休眠状态  </p>
<p>使用步骤如下：</p>
<ol>
<li><p>定义信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sema_init</span><span class="params">(struct semaphore *sem,<span class="keyword">int</span> val)</span></span>;	<span class="comment">//初始化并设置为val</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_MUTEX</span><span class="params">(struct semaphore *sem)</span></span>;			<span class="comment">//初始化并设置为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_MUTEX_LOCKED</span><span class="params">(struct semaphore *sem)</span></span>;	<span class="comment">//初始化并设置为0</span></span><br></pre></td></tr></table></figure>

<p>下面两个宏用于定义并初始化信号量的“快捷方式”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_MUTEX(name);		<span class="comment">//初始化并设置为1</span></span><br><span class="line">DECLARE_MUTEX_LOCKED(name);	<span class="comment">//初始化并设置为0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(struct semaphore *sem)</span></span>;				<span class="comment">//会导致休眠，不能在中断上下文使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">down_interruptible</span><span class="params">(struct semaphore *sem)</span></span>;	<span class="comment">//不会导致休眠，可在中断上下文使用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>释放信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(struct semaphore *sem)</span></span>;	<span class="comment">//释放信号量sem，唤醒等待者</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>使用示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_MUTEX(mount_sem);</span><br><span class="line">down(&amp;mount_sem);获取信号量，保护临界区</span><br><span class="line">...</span><br><span class="line">critical section <span class="comment">//临界区</span></span><br><span class="line">...</span><br><span class="line">up(&amp;mount_sem);<span class="comment">//释放信号量</span></span><br></pre></td></tr></table></figure>

<h2 id="什么是死锁-如何避免死锁">6.2 什么是死锁?如何避免死锁?</h2><h3 id="什么是死锁">6.2.1 什么是死锁</h3><p>​    死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p>　例如，在某个计算机系统中只有一台打印机和一台输入 设备，进程P1正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2  所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态</p>
<h3 id="死锁产生的原因">6.2.2 死锁产生的原因</h3><ol>
<li><p>系统资源的竞争</p>
</li>
<li><p>进程运行推进顺序不当引起死锁</p>
<ul>
<li><p>进程推进顺序合法</p>
<p>当进程P1和P2并发执行时，如果按照下述顺序推进：P1：Request（R1）； P1：Request（R2）； P1: Relese（R1）；P1: Relese（R2）； P2：Request（R2）；  P2：Request（R1）； P2: Relese（R2）；P2:  Relese（R1）；这两个进程便可顺利完成，这种不会引起进程死锁的推进顺序是合法的</p>
</li>
<li><p>进程推进顺序非法</p>
<p>若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁。</p>
</li>
</ul>
</li>
</ol>
<h3 id="产生死锁的四个必要条件">6.2.3 产生死锁的四个必要条件</h3><ul>
<li><p>互斥条件</p>
<p>指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p>
</li>
<li><p>请求与保持条件</p>
<p>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p>
</li>
<li><p>不可剥夺条件</p>
<p>进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</p>
</li>
<li><p>循环等待条件</p>
<p>指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p>
</li>
</ul>
<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<h3 id="死锁的避免与预防">6.2.4 死锁的避免与预防</h3><p>　　理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。只要打破四个必要条件之一就能有效预防死锁的发生：</p>
<ul>
<li><p>打破互斥条件</p>
<p>改造独占性资源为虚拟资源，大部分资源已无法改造。</p>
</li>
<li><p>打破不可抢占条件</p>
<p>当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源</p>
</li>
<li><p>打破占有且申请条件</p>
<p>采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</p>
</li>
<li><p>打破循环等待条件</p>
<p>实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</p>
</li>
</ul>
<p>死锁避免和死锁预防的区别：</p>
<p>​    死锁预防是设法至少破坏产生死锁的四个必要条件之一，严格的防止死锁的出现；而死锁避免则不那么严格的限制产生死锁的必要条件的存在，因为即使死锁的必要条件存在，也不一定发生死锁。死锁避免是在系统运行过程中注意避免死锁的最终发生。</p>
<h2 id="驱动里面为什么要有并发、互斥的控制？如何实现？讲个例子？">6.3 驱动里面为什么要有并发、互斥的控制？如何实现？讲个例子？</h2><p>   并发（concurrency）指的是多个执行单元同时、并行被执行，而并发的执行单元对共享资源（硬件资源和软件上的全局变量、静态变量等）的访问则很容易导致竞态（race conditions）。</p>
<p>​    解决竞态问题的途径是保证对共享资源的互斥访问，所谓互斥访问就是指一个执行单元 在访问共享资源的时候，其他的执行单元都被禁止访问。</p>
<p>​    访问共享资源的代码区域被称为临界区，临界区需要以某种互斥机制加以保护，中断屏蔽，原子操作，自旋锁，和信号量都是linux设备驱动中可采用的互斥途径。</p>
<h1 id="中断相关">7 中断相关</h1><h2 id="系统软中断、tasklet、工作队列work-queue的区别及使用">7.1 系统软中断、tasklet、工作队列work queue的区别及使用</h2><p>中断上半部：</p>
<ul>
<li>对时间要求比较高的工作</li>
<li>硬件相关的操作</li>
<li>不能被中断打断，因为进入中断时候一般都会禁止本地CPU中断</li>
</ul>
<p>中断下半部：</p>
<ul>
<li>可延迟执行的操作（对时间要求不高）</li>
</ul>
<h3 id="软中断">7.1.1 软中断</h3><p>目前Linux系统最多支持32个软中断，系统已经定义使用了10个，剩下的用户可以自己指定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">    TIMER_SOFTIRQ,</span><br><span class="line">    NET_TX_SOFTIRQ,</span><br><span class="line">    NET_RX_SOFTIRQ,</span><br><span class="line">    BLOCK_SOFTIRQ,</span><br><span class="line">    BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">    TASKLET_SOFTIRQ,</span><br><span class="line">    SCHED_SOFTIRQ,</span><br><span class="line">    HRTIMER_SOFTIRQ,</span><br><span class="line">    RCU_SOFTIRQ,    <span class="comment">/* Preferable RCU should always be the last softirq */</span></span><br><span class="line"></span><br><span class="line">    NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面列出的软中断类型越靠前优先级越高，其中有两个需要关注一下，就是HI_SOFTIRQ和TASKLET_SOFTIRQ，系统已经帮我们初始化好了，tasklet就是基于这两个软中断去实现的。具体代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//init/main.c</span></span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __init <span class="title">start_kernel</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *command_line;</span><br><span class="line">    <span class="keyword">char</span> *after_dashes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Need to run as early as possible, to initialize the</span></span><br><span class="line"><span class="comment">     * lockdep hash:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lockdep_init();</span><br><span class="line">    set_task_stack_end_magic(&amp;init_task);</span><br><span class="line">    smp_setup_processor_id();</span><br><span class="line">    debug_objects_early_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Set up the the initial canary ASAP:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    boot_init_stack_canary();</span><br><span class="line"></span><br><span class="line">    cgroup_init_early();</span><br><span class="line"></span><br><span class="line">    local_irq_disable();</span><br><span class="line">    early_boot_irqs_disabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    ....    ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * These use large bootmem allocations and must precede</span></span><br><span class="line"><span class="comment">     * kmem_cache_init()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    setup_log_buf(<span class="number">0</span>);</span><br><span class="line">    pidhash_init();</span><br><span class="line">    vfs_caches_init_early();</span><br><span class="line">    sort_main_extable();</span><br><span class="line">    trap_init();</span><br><span class="line">    mm_init();</span><br><span class="line">    ....    ....</span><br><span class="line">    early_irq_init();</span><br><span class="line">    init_IRQ();</span><br><span class="line">    tick_init();</span><br><span class="line">    rcu_init_nohz();</span><br><span class="line">    init_timers();</span><br><span class="line">    hrtimers_init();</span><br><span class="line">    softirq_init();<span class="comment">//初始化软中断</span></span><br><span class="line">    timekeeping_init();</span><br><span class="line">    time_init();</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_ESPFIX64</span></span><br><span class="line">    <span class="comment">/* Should be run before the first non-init thread is created */</span></span><br><span class="line">    init_espfix_bsp();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    thread_info_cache_init();</span><br><span class="line">    cred_init();</span><br><span class="line">    fork_init();</span><br><span class="line">    ....    ....</span><br><span class="line"></span><br><span class="line">    check_bugs();</span><br><span class="line"></span><br><span class="line">    acpi_subsystem_init();</span><br><span class="line">    sfi_init_late();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (efi_enabled(EFI_RUNTIME_SERVICES)) &#123;</span><br><span class="line">        efi_late_init();</span><br><span class="line">        efi_free_boot_services();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ftrace_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do the rest non-__init'ed, we're now alive */</span></span><br><span class="line">    rest_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//kernel/softirq.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">softirq_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">    for_each_possible_cpu(cpu) &#123;</span><br><span class="line">        per_cpu(tasklet_vec, cpu).tail =</span><br><span class="line">            &amp;per_cpu(tasklet_vec, cpu).head;</span><br><span class="line">        per_cpu(tasklet_hi_vec, cpu).tail =</span><br><span class="line">            &amp;per_cpu(tasklet_hi_vec, cpu).head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open_softirq(TASKLET_SOFTIRQ, tasklet_action);</span><br><span class="line">    open_softirq(HI_SOFTIRQ, tasklet_hi_action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<p>open_softirq(TASKLET_SOFTIRQ, tasklet_action);</p>
<p>open_softirq(HI_SOFTIRQ, tasklet_hi_action);</p>
<p>就是系统为我们初始化好的和tasklet相关的软中断。</p>
<h4 id="自定义软中断">7.1.1.1 自定义软中断</h4><p>我们也可以自己定义属于自己的软中断，方法如下:</p>
<ol>
<li><p>添加我们自己的软中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">    TIMER_SOFTIRQ,</span><br><span class="line">    NET_TX_SOFTIRQ,</span><br><span class="line">    NET_RX_SOFTIRQ,</span><br><span class="line">    BLOCK_SOFTIRQ,</span><br><span class="line">    BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">    TASKLET_SOFTIRQ,</span><br><span class="line">    SCHED_SOFTIRQ,</span><br><span class="line">    HRTIMER_SOFTIRQ,</span><br><span class="line">    MY_SOFTIRQ,      <span class="comment">/*我自己添加的软中断*/</span> </span><br><span class="line">    RCU_SOFTIRQ,    <span class="comment">/* Preferable RCU should always be the last softirq */</span></span><br><span class="line"></span><br><span class="line">    NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在kernel/softirq.c中定义自己的软中断处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我自己定义的软中断处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_softirq_action</span><span class="params">(struct softirq_action *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">softirq_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">    for_each_possible_cpu(cpu) &#123;</span><br><span class="line">        per_cpu(tasklet_vec, cpu).tail =</span><br><span class="line">            &amp;per_cpu(tasklet_vec, cpu).head;</span><br><span class="line">        per_cpu(tasklet_hi_vec, cpu).tail =</span><br><span class="line">            &amp;per_cpu(tasklet_hi_vec, cpu).head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open_softirq(TASKLET_SOFTIRQ, tasklet_action);</span><br><span class="line">    open_softirq(HI_SOFTIRQ, tasklet_hi_action);</span><br><span class="line">    open_softirq(MY_SOFTIRQ, tasklet_hi_action);<span class="comment">//我自己定义的软中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>激活</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise_softirq(MY_SOFTIRQ);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>以上就是自己定义的软中断的流程。</p>
<h4 id="软中断的执行">7.1.1.2 软中断的执行</h4><p>软中断的执行既可以守护进程(ksoftirqd)中执行，也可以在中断的退出阶段执行。实际上，软中断更多的是在中断的退出阶段执行（irq_exit），以便达到更快的响应，加入守护进程机制，只是担心一旦有大量的软中断等待执行，会使得内核过长地留在中断上下文中。</p>
<h5 id="在irq-exit中执行">7.1.1.2.1 在irq_exit中执行</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">irq_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">	sub_preempt_count(IRQ_EXIT_OFFSET);</span><br><span class="line">	<span class="keyword">if</span> (!in_interrupt() &amp;&amp; local_softirq_pending())</span><br><span class="line">		invoke_softirq();</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果中断发生嵌套，in_interrupt()保证了只有在最外层的中断的irq_exit阶段，invoke_interrupt才会被调用，当然，local_softirq_pending也会实现判断当前cpu有无待决的软中断。代码最终会进入<strong>do_softirq中，内核会保证调用</strong>do_softirq时，本地cpu的中断处于关闭状态，进入__do_softirq：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="keyword">void</span> __do_softirq(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        ......</span><br><span class="line">	pending = local_softirq_pending();</span><br><span class="line"> </span><br><span class="line">	__local_bh_disable((<span class="keyword">unsigned</span> <span class="keyword">long</span>)__builtin_return_address(<span class="number">0</span>),</span><br><span class="line">				SOFTIRQ_OFFSET);</span><br><span class="line">restart:</span><br><span class="line">	<span class="comment">/* Reset the pending bitmask before enabling irqs */</span></span><br><span class="line">	set_softirq_pending(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">	local_irq_enable();</span><br><span class="line"> </span><br><span class="line">	h = softirq_vec;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (pending &amp; <span class="number">1</span>) &#123;</span><br><span class="line">	                ......</span><br><span class="line">			trace_softirq_entry(vec_nr);</span><br><span class="line">			h-&gt;action(h);</span><br><span class="line">			trace_softirq_exit(vec_nr);</span><br><span class="line">                        ......</span><br><span class="line">		&#125;</span><br><span class="line">		h++;</span><br><span class="line">		pending &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span> (pending);</span><br><span class="line"> </span><br><span class="line">	local_irq_disable();</span><br><span class="line"> </span><br><span class="line">	pending = local_softirq_pending();</span><br><span class="line">	<span class="keyword">if</span> (pending &amp;&amp; --max_restart)</span><br><span class="line">		<span class="keyword">goto</span> restart;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (pending)</span><br><span class="line">		wakeup_softirqd();</span><br><span class="line"> </span><br><span class="line">	lockdep_softirq_exit();</span><br><span class="line"> </span><br><span class="line">	__local_bh_enable(SOFTIRQ_OFFSET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先取出pending的状态；</li>
<li>禁止软中断，主要是为了防止和软中断守护进程发生竞争；</li>
<li>清除所有的软中断待决标志</li>
<li>打开本地cpu中断；</li>
<li>循环执行待决软中断的回调函数</li>
<li>如果循环完毕，发现新的软中断被触发，则重新启动循环，直到以下条件满足，才退出：<ul>
<li>没有新的软中断等待执行</li>
<li>循环已经达到最大的循环次数MAX_SOFTIRQ_RESTART，目前的设定值时10次；</li>
</ul>
</li>
<li>如果经过MAX_SOFTIRQ_RESTART次循环后还未处理完，则激活守护进程，处理剩下的软中断；</li>
<li>退出前恢复软中断</li>
</ul>
<h5 id="在ksoftirqd进程中执行">7.1.1.2.2 在ksoftirqd进程中执行</h5><p>软中断也可能由ksoftirqd守护进程执行，这要发生在以下两种情况下：</p>
<ul>
<li>在irq_exit中执行软中断，但是在经过MAX_SOFTIRQ_RESTART次循环后，软中断还未处理完，这种情况虽然极少发生，但毕竟有可能；</li>
<li>内核的其它代码主动调用raise_softirq，而这时正好不是在中断上下文中，守护进程将被唤醒；</li>
</ul>
<p>守护进程最终也会调用__do_softirq执行软中断的回调，具体的代码位于run_ksoftirqd函数中，内核会关闭抢占的情况下执行__do_softirq。</p>
<h3 id="tasklet">7.1.2 tasklet</h3><p>因为内核已经定义好了10种软中断类型，并且不建议我们自行添加额外的软中断，所以对软中断的实现方式，我们主要是做一个简单的了解，对于驱动程序的开发者来说，无需实现自己的软中断。但是，对于某些情况下，我们不希望一些操作直接在中断的handler中执行，但是又希望在稍后的时间里得到快速地处理，这就需要使用tasklet机制。 tasklet是建立在软中断上的一种延迟执行机制，它的实现基于TASKLET_SOFTIRQ和HI_SOFTIRQ这两个软中断类型。</p>
<p>tasklet示例如下：</p>
<ol>
<li><p>定一个tasklet类型的结构体变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用tasklet机制的中断下半部*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">my_tasklet</span>;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写软中断处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_tasklet_fun</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化，将tasklet软中断处理函数和tasklet挂钩</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklet_init(my_tasklet,my_tasklet_fun,(<span class="keyword">unsigned</span> <span class="keyword">long</span>) sport);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用tasklet_schedule触发调度tasklet</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklet_schedule(&amp;sport-&gt;my_tasklet);<span class="comment">//调度tasklet</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>定义tasklet变量，实现软中断处理函数，初始化，调度，以上这些就是tasklet的使用步骤了，内核帮我们省略了很多麻烦的实现，所以使用起来比较简单。</p>
<h3 id="工作队列work-queue">7.1.3 工作队列work queue</h3><p>软中断和tasklet是运行于中断上下文的，它们属于内核态没有进程的切换，因此在执行过程中不能休眠，不能阻塞，一旦休眠或者阻塞，则系统直接挂死。因此软中断和tasklet是有一定的使用局限性的，工作队列的出现正是用在软中断和tasklet不能使用的场合，比如需要调用一个具有可延迟函数的特质，但是这个函数又有可能引起休眠、阻塞。</p>
<p>工作队列的使用步骤如下：</p>
<ol>
<li><p>定义一个工作队列对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*工作队列机制*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>    <span class="title">my_work</span>;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写工作队列处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*工作队列机制*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_work_fun</span><span class="params">(struct work_struct *w)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化工作队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INIT_WORK(&amp;my_work, my_work_fun);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调度工作队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schedule_work(&amp;my_work);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="linux中断响应的执行流程">7.2 linux中断响应的执行流程</h2><p><img src="/2020/06/25/面试-驱动开发/irq_liucheng.jpg" alt></p>
<p><img src="/2020/06/25/面试-驱动开发/Interrupt_response.png" alt></p>
<p>这个序列图展示了整个通用中断子系统的中断响应过程，flow_handle一栏就是中断流控层的生命周期</p>
<h2 id="中断注册函数和中断注销函数">7.3 中断注册函数和中断注销函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request_threaded_irq(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq,</span><br><span class="line">                     <span class="keyword">irq_handler_t</span> handler,</span><br><span class="line">                     <span class="keyword">irq_handler_t</span> thread_fn,</span><br><span class="line">                     <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span><br><span class="line">                     <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">                     <span class="keyword">void</span> *dev);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>irq</p>
<p>需要申请的irq编号，对于ARM体系，irq编号通常在平台级的代码中事先定义好，有时候也可以动态申请。</p>
</li>
<li><p>handler</p>
<p>中断服务回调函数，该回调运行在中断上下文中，并且cpu的本地中断处于关闭状态，所以该回调函数应该只是执行需要快速响应的操作，执行时间应该尽可能短小，耗时的工作最好留给下面的thread_fn回调处理。</p>
</li>
<li><p>thread_fn</p>
<p>如果该参数不为NULL，内核会为该irq创建一个内核线程，当中断发生时，如果handler回调返回值是IRQ_WAKE_THREAD，内核将会激活中断线程，在中断线程中，该回调函数将被调用，所以，该回调函数运行在进程上下文中，允许进行阻塞操作。</p>
</li>
<li><p>flags</p>
<p>控制中断行为的位标志。例如：IRQF_TRIGGER_RISING，IRQF_TRIGGER_LOW，IRQF_SHARED等，在include/linux/interrupt.h中定义。</p>
</li>
<li><p>name</p>
<p>申请本中断服务的设备名称，同时也作为中断线程的名称，该名称可以在/proc/interrupts文件中显示。</p>
</li>
<li><p>dev</p>
<p>当多个设备的中断线共享同一个irq时，它会作为handler的参数，用于区分不同的设备。</p>
</li>
</ul>
<h2 id="中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？">7.4 中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？</h2><p>中断是CPU处于被动状态下来接受设备的信号，而轮询是CPU主动去查询该设备是否有请求。凡事都是两面性，所以，看效率不能简单的说那个效率高。如果是请求设备是一个频繁请求cpu的设备，或者有大量数据请求的网络设备，那么轮询的效率是比中断高。如果是一般设备，并且该设备请求cpu的频率比较底，则用中断效率要高一些。主要是看请求频率</p>
<h2 id="写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情你是怎么做的？">7.5 写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情你是怎么做的？</h2><ul>
<li>中断处理例程应该尽量短<strong>，</strong>把能放在后半段(tasklet，等待队列等)的任务尽量放在后半段</li>
<li>中断服务程序中不能有阻塞操作。应为中断期间是完全占用CPU的（即不存在内核调度），中断被阻塞住，其他进程将无法操作；</li>
<li>中断服务程序注意返回值，要用操作系统定义的宏做为返回值，而不是自己定义的OK，FAIL之类的。</li>
</ul>
<h2 id="驱动中操作物理绝对地址为什么要先ioremap">7.6 驱动中操作物理绝对地址为什么要先ioremap?</h2><p>因为内核没有办法直接访问物理内存地址，必须先<strong>通过ioremap获得对应的虚拟地址</strong>。</p>
<h2 id="IRQ和FIQ有什么区别？">7.7 IRQ和FIQ有什么区别？</h2><p>一般的中断控制器里我们可以配置与控制器相连的某个中断输入是FIQ还是IRQ,所以一个中断是可以指定为FIQ或者IRQ的，为了合理，要求系统更快响应，自身处理所耗时间也很短的中断设置为FIQ，否则就设置了IRQ。</p>
<p>区别如下：</p>
<ul>
<li>FIQ比IRQ有更高优先级</li>
<li>IRQ可以被FIQ所中断，但FIQ不能被IRQ所中断。</li>
<li>FIQ模式下，比IRQ模式多了几个独立的寄存器</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/面试/" rel="tag"># 面试</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/25/面试-操作系统/" rel="next" title="面试-操作系统">
                <i class="fa fa-chevron-left"></i> 面试-操作系统
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/28/kernel-panic-详解/" rel="prev" title="kernel panic 详解">
                kernel panic 详解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="gitalk-container">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

		
		  
			<ul class="sidebar-nav motion-element">
			  <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
				文章目录
			  </li>
			  <li class="sidebar-nav-overview" data-target="site-overview-wrap">
				站点概览
			  </li>
			</ul>
		  
		

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/han.jpg" alt="Rulei.Zhou">
            
              <p class="site-author-name" itemprop="name">Rulei.Zhou</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/ruleizhou" title="GitHub &rarr; https://github.com/ruleizhou" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:rulei.zhou@foxmail.com" title="E-Mail &rarr; mailto:rulei.zhou@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section></div>

		
		  
		  <!--noindex-->
			<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
			  <div class="post-toc">

				
				  
				

				
				  <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux相关"><span class="nav-text">1 Linux相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux中用户模式和内核模式是什么含意？"><span class="nav-text">1.1 Linux中用户模式和内核模式是什么含意？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux用户进程间通信主要有哪几种方式？"><span class="nav-text">1.2 linux用户进程间通信主要有哪几种方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux内存如何划分及如何使用？虚拟地址及物理地址的概念及转换，高端内存的概念？"><span class="nav-text">1.3 linux内存如何划分及如何使用？虚拟地址及物理地址的概念及转换，高端内存的概念？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux中内核空间和用户空间区别？用户空间和内核空间通信方式有哪些？"><span class="nav-text">1.4 linux中内核空间和用户空间区别？用户空间和内核空间通信方式有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux中系统调用过程？如应用程序中read-在linux中执行过程（从用户空间到内核空间）？"><span class="nav-text">1.5 linux中系统调用过程？如应用程序中read()在linux中执行过程（从用户空间到内核空间）？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux调度原理"><span class="nav-text">1.6 linux调度原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux-RCU原理"><span class="nav-text">1.7 linux RCU原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux编译时用到的参数含义"><span class="nav-text">1.8 linux编译时用到的参数含义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux内核的启动过程（源代码级）"><span class="nav-text">1.9 linux内核的启动过程（源代码级）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基础相关"><span class="nav-text">2 基础相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么用C先嵌入式系统的死循环的？"><span class="nav-text">2.1 怎么用C先嵌入式系统的死循环的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#copy-to-user-和copy-from-user-主要用于实现什么功能？一般用于file-operations结构的哪些函数里面？"><span class="nav-text">2.2 copy_to_user() 和copy_from_user()主要用于实现什么功能？一般用于file_operations结构的哪些函数里面？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ioctl和unlock-ioctl有什么区别？"><span class="nav-text">2.3 ioctl和unlock_ioctl有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kmalloc和vmalloc的区别"><span class="nav-text">2.4 kmalloc和vmalloc的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内核函数mmap的实现原理，机制？"><span class="nav-text">2.5 内核函数mmap的实现原理，机制？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎样申请大块内核内存？"><span class="nav-text">2.6 怎样申请大块内核内存？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#framebuffer机制"><span class="nav-text">2.7 framebuffer机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内核配置编译及Makefile"><span class="nav-text">2.8 内核配置编译及Makefile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列举最少3种你所知道的嵌入式的体系结构，并请说明什么时ARM体系结构？"><span class="nav-text">2.9 列举最少3种你所知道的嵌入式的体系结构，并请说明什么时ARM体系结构？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#驱动模型相关"><span class="nav-text">3 驱动模型相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字符设备和块设备的区别，请分别列举一些实际的设备说出它们是属于哪一类设备？"><span class="nav-text">3.1 字符设备和块设备的区别，请分别列举一些实际的设备说出它们是属于哪一类设备？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请简述主设备号和次设备号的用途。如果执行mknod-chartest-c-4-64，创建chartest设备。请分析chartest使用的是哪一类设备驱动程序？"><span class="nav-text">3.2 请简述主设备号和次设备号的用途。如果执行mknod chartest c 4 64，创建chartest设备。请分析chartest使用的是哪一类设备驱动程序？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设备驱动程序中如何注册一个字符设备？分别解释下它的几个参数的含义？"><span class="nav-text">3.3 设备驱动程序中如何注册一个字符设备？分别解释下它的几个参数的含义？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符型驱动设备怎么创建文件？"><span class="nav-text">3.4 字符型驱动设备怎么创建文件？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#insmod一个驱动模块，会执行模块中的哪个函数？rmmod呢？这两个函数在设计上要注意哪些？遇到过卸载驱动出现异常没？是什么问题引起的？"><span class="nav-text">3.5 insmod一个驱动模块，会执行模块中的哪个函数？rmmod呢？这两个函数在设计上要注意哪些？遇到过卸载驱动出现异常没？是什么问题引起的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设备驱动模型三个重要的成员是？platform总线的匹配规则是？在具体应用上要不要先注册驱动在注册设备？有先后顺序没？"><span class="nav-text">3.6 设备驱动模型三个重要的成员是？platform总线的匹配规则是？在具体应用上要不要先注册驱动在注册设备？有先后顺序没？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#驱动中操作物理绝对地址为什么要先ioremap？"><span class="nav-text">3.7 驱动中操作物理绝对地址为什么要先ioremap？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看驱动模块中打印信息应该使用什么命令？如何查看内核中已有的字符设备的信息？如何查看正在使用的哪些中断号？"><span class="nav-text">3.8 查看驱动模块中打印信息应该使用什么命令？如何查看内核中已有的字符设备的信息？如何查看正在使用的哪些中断号？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bus相关"><span class="nav-text">4 Bus相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#I2C"><span class="nav-text">4.1 I2C</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I2C总线协议和时序"><span class="nav-text">4.1.1 I2C总线协议和时序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总线空闲状态"><span class="nav-text">4.1.1.1 总线空闲状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#启动信号（start）"><span class="nav-text">4.1.1.2 启动信号（start）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#停止信号（stop）"><span class="nav-text">4.1.1.3 停止信号（stop）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据位传送"><span class="nav-text">4.1.1.4 数据位传送</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应答信号（ACK）"><span class="nav-text">4.1.1.5 应答信号（ACK）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I2C通讯时序图"><span class="nav-text">4.1.2 I2C通讯时序图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I2C总线体系结构"><span class="nav-text">4.1.3 I2C总线体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#相关结构体"><span class="nav-text">4.1.3.1 相关结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I2C设备驱动"><span class="nav-text">4.1.3.2 I2C设备驱动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I2C核心"><span class="nav-text">4.1.3.3 I2C核心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I2C总线驱动"><span class="nav-text">4.1.3.4 I2C总线驱动</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I2C设备驱动编写"><span class="nav-text">4.1.4 I2C设备驱动编写</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Debug相关"><span class="nav-text">5 Debug相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Kernel-Oops和Panic是一回事吗"><span class="nav-text">5.1 Kernel Oops和Panic是一回事吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kernel-Panic"><span class="nav-text">5.2 Kernel Panic</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#同步相关"><span class="nav-text">6 同步相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#linux中的同步机制？"><span class="nav-text">6.1 linux中的同步机制？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自旋锁"><span class="nav-text">6.1.1 自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#互斥锁"><span class="nav-text">6.1.2 互斥锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量"><span class="nav-text">6.1.3 信号量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是死锁-如何避免死锁"><span class="nav-text">6.2 什么是死锁?如何避免死锁?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是死锁"><span class="nav-text">6.2.1 什么是死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁产生的原因"><span class="nav-text">6.2.2 死锁产生的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#产生死锁的四个必要条件"><span class="nav-text">6.2.3 产生死锁的四个必要条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁的避免与预防"><span class="nav-text">6.2.4 死锁的避免与预防</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#驱动里面为什么要有并发、互斥的控制？如何实现？讲个例子？"><span class="nav-text">6.3 驱动里面为什么要有并发、互斥的控制？如何实现？讲个例子？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#中断相关"><span class="nav-text">7 中断相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#系统软中断、tasklet、工作队列work-queue的区别及使用"><span class="nav-text">7.1 系统软中断、tasklet、工作队列work queue的区别及使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#软中断"><span class="nav-text">7.1.1 软中断</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义软中断"><span class="nav-text">7.1.1.1 自定义软中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#软中断的执行"><span class="nav-text">7.1.1.2 软中断的执行</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#在irq-exit中执行"><span class="nav-text">7.1.1.2.1 在irq_exit中执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在ksoftirqd进程中执行"><span class="nav-text">7.1.1.2.2 在ksoftirqd进程中执行</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tasklet"><span class="nav-text">7.1.2 tasklet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工作队列work-queue"><span class="nav-text">7.1.3 工作队列work queue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux中断响应的执行流程"><span class="nav-text">7.2 linux中断响应的执行流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中断注册函数和中断注销函数"><span class="nav-text">7.3 中断注册函数和中断注销函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？"><span class="nav-text">7.4 中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情你是怎么做的？"><span class="nav-text">7.5 写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情你是怎么做的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#驱动中操作物理绝对地址为什么要先ioremap"><span class="nav-text">7.6 驱动中操作物理绝对地址为什么要先ioremap?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IRQ和FIQ有什么区别？"><span class="nav-text">7.7 IRQ和FIQ有什么区别？</span></a></li></ol></li></ol></div>
				

			  </div>
			</section>
		  <!--/noindex-->
		  
		

      

    </aside></div>
  
  


        
      </main></div>
    

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rulei.Zhou</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.2"></script>




  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  


  
    

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">



<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: '0a400e1f09cb117f3ea4',
    clientSecret: 'f7d98253e2a12b03803742f2a506c174d06019a0',
    repo: 'ruleizhou.github.io',
    owner: 'ruleizhou',
    admin: ['ruleizhou'],
    id: md5(location.pathname),
    
      language: window.navigator.language || window.navigator.userLanguage,
    
    distractionFreeMode: 'true'
  });
  gitalk.render('gitalk-container');
</script>

  


  




  

  

  

  

  

  

  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('复制成功')
          else $(this).text('复制失败')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


  

  

</body>
</html>
